# CPU和内存模型
这里想介绍的主要是一些计算机的概念：CPU、寄存器、高速缓存、主内存、硬盘相关知识，以及为了实现高速缓存的一致性而设置的MESI协议等。

## cpu与内存模型的结构图

https://pic1.zhimg.com/80/v2-f7df2460ef1d2af17bbf1b2a9d6bb550_1440w.jpg
https://pic2.zhimg.com/80/v2-c8c982aa5384854a804ab3a5a57488f5_1440w.jpg

可以看到，除了寄存器，在CPU和主内存之间还设置了三级缓存，这样做的目的是为了平衡CPU处理速度和从内存中读取数据的速度之间的差异，避免CPU停下来等待从内存中读取数据。
设置了缓存之后，CPU只需要和缓存进行交互获取数据，缓存未命中时再去内存中读取数据，并保留一份在缓存中（原理：程序局部性原理）

缓存：基本上都是采用SRAM（Static RAM，静态存储器），无需刷新电路就可以保存已经存储的数据（DRAM需要定期刷新充电，否则内存数据会消失），但缺点就是体积较大，而DRAM在存储相同大小的数据有更小的体积。

现代CPU增加了多核、多CPU的场景，极大提高了线程的并发性，随之而来的问题就是在缓存和内存之间的数据一致性。

## 缓存一致性问题：
### 背景
多核CPU的情况下有多个一级缓存，为了保证缓存内部的数据一致性，引入了一致性协议MESI。
### MESI
缓存行：缓存中存储数据的单元。MESI其实分别代表了缓存行的四个状态：

| 状态 | 说明 | 监听任务 |
| :------:| :------: | :------: |
| M(Modified) | 缓存行已修改，和内存不一致 | 缓存行必须时刻监听所有试图读取该缓存行相对应的主存数据，必须在该缓存行回写到主存才能读取，此时缓存行状态变为共享（S）|
|E(Exclusive)|独享、互斥，说明缓存行只在当前缓存中，且和主存数据相同|需要监听其他缓存行读取主存的操作，一旦有读取，则状态变为共享（S）|
| S(Shared) | 共享，数据存在很多缓存中 | 必须监听其他缓存使该缓存行无效或独占该缓存行的操作，此时将缓存行变为无效 |
|I(Invalid)|该缓存行无效|无|

<font color="#dd0000">注：</font><br />
这里面的状态，M和E是精确的，因为他们是和缓存行的真正状态是一致的，而S状态不一定。因为如果一个缓存将S状态的缓存行作废，另一个缓存可能独享了该缓存行，但该缓存并不会讲状态升迁为E，因为其他缓存不会广播作废的通知，同样也没办法确定自己是否独占了该缓存行。

状态之间的流转参考链接：https://www.cnblogs.com/yanlong300/p/8986041.html?spm=ata.21736010.0.0.ff105f019sqMxD

### 内存屏障
为了解决这种缓存不一致问题，同时操作系统可能存在重排序导致的错误，操作系统提供内存屏障解决这个问题。<br />
1. CPU操作的数据直接更新到主内存，保证内存可见性 <br />
2. 屏蔽CPU指令管道化优化，屏蔽指令排序，按照期望的顺序进行执行。

实现方案：<br />
1. 硬件层面：写屏障（Store Memory Barrier）和读屏障（Load Memory Barrier）
```
void executedOnCpu0() {
    value = 10;
    //在更新数据之前必须将所有存储缓存（store buffer）中的指令执行完毕。
    storeMemoryBarrier();
    finished = true;
}
void executedOnCpu1() {
    while(!finished);
    //在读取之前将所有失效队列中关于该数据的指令执行完毕。
    loadMemoryBarrier();
    assert value == 10;
}
```
2. 软件层面：屏蔽OS差异，统一由JVM进行内存屏障。如volatile和synchronzied。
